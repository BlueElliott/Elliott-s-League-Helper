# League of Legends Custom Rune/Item Manager - Complete Summary
**Research & Technical Specifications**

## PROJECT OVERVIEW

Build a lightweight, ad-free League of Legends companion app that:
- Auto-imports runes via LCU API
- Auto-imports item builds via file system
- Supports multiple data sources (U.GG, OP.GG, Lolalytics)
- Uses aggressive caching for instant performance
- No Overwolf, no ads, no bloat

---

## COMPETITOR ANALYSIS

### Top 5 Apps Comparison:

| App | Platform | RAM Usage | User Rating | Pros | Cons |
|-----|----------|-----------|-------------|------|------|
| **Mobalytics** | Overwolf | 400-600MB | 3.6‚òÖ | Best features, GPI system | Heavy, ads, performance issues |
| **Blitz** | Overwolf | 300-500MB | 3.5‚òÖ | Full automation | Heavy paywall, ad overload |
| **Porofessor** | Overwolf | 350-550MB | 4.1‚òÖ | Best pre-game analysis | Overwolf required, dated website |
| **U.GG** | Standalone | 150-250MB | 4.0‚òÖ | Clean UI, lightweight | Limited features |
| **iTero** | Standalone | ~200MB | 4.5‚òÖ | AI-powered, best performance | Newer, smaller user base |

**Your App Target:**
- Platform: Standalone Python
- RAM: 50-80MB (6-12x lighter than competitors)
- Features: Runes + Items + Multi-source + Zero ads

---

## TECHNICAL ARCHITECTURE

### Core Components:

```
1. LCU Connector
   - Auto-detect League client (lockfile or process)
   - WebSocket for real-time events
   - REST API for rune/summoner spell management

2. Rune Provider System (Multi-source)
   - U.GG scraper (JSON API-like)
   - OP.GG scraper (HTML parsing)
   - Lolalytics scraper
   - User selects preferred source

3. Cache Layer (SQLite)
   - 3.5 MB total for ALL champions
   - 95%+ cache hit rate
   - 24-hour TTL per patch
   - Background refresh

4. Item Set Writer
   - Direct file writes to Config directory
   - No LCU API needed
   - Instant file creation

5. UI (Minimal)
   - System tray (pystray)
   - Settings window (PyQt6 or tkinter)
   - Optional: Flask web UI (like Singular Tweaks)
```

---

## HOW RUNES WORK

### LCU API Endpoints:

```python
# WebSocket: Champion lock detection
wss://127.0.0.1:{PORT}/
Event: /lol-champ-select/v1/session

# REST: Get current rune pages
GET /lol-perks/v1/pages

# REST: Delete rune page
DELETE /lol-perks/v1/pages/{id}

# REST: Create new rune page
POST /lol-perks/v1/pages
Body: {
    "name": "U.GG - Ahri Mid",
    "primaryStyleId": 8200,
    "subStyleId": 8000,
    "selectedPerkIds": [8214, 8224, 8233, 8237, 8345, 8347, 5008, 5008, 5001],
    "current": true
}
```

### Authentication:
```python
# Username: "riot" (constant)
# Password: From lockfile or process command line
# Header: Authorization: Basic base64("riot:PASSWORD")
# SSL: Self-signed cert (disable verification)
```

---

## HOW ITEM BUILDS WORK

### File System Method (What Apps Actually Use):

**Location:**
```
C:\Riot Games\League of Legends\Config\Champions\{ChampionKey}\Recommended\
```

**File Format:**
```json
{
  "title": "U.GG - Ahri Mid",
  "associatedMaps": [11],
  "associatedChampions": [103],
  "blocks": [
    {
      "type": "Starting Items",
      "items": [
        {"id": "1056", "count": 1},
        {"id": "2003", "count": 2}
      ]
    },
    {
      "type": "Core Build",
      "recMath": false,
      "items": [
        {"id": "3020", "count": 1},
        {"id": "6653", "count": 1},
        {"id": "3135", "count": 1}
      ]
    }
  ]
}
```

**How It Works:**
1. Champion locks in champ select
2. App writes JSON file to disk
3. League reads file on game start
4. Item set appears in shop dropdown

**No LCU API needed - just direct file writes (10ms)**

---

## REAL-TIME PERFORMANCE STRATEGY

### The Problem:
```
User locks champion ‚Üí Fetch from API (300ms) ‚Üí Apply (100ms) = 400ms lag
```

### The Solution: Aggressive Caching

**SQLite Cache Schema:**
```sql
CREATE TABLE rune_cache (
    champion_id INTEGER,
    role TEXT,
    game_mode TEXT,  -- 'rift', 'aram', 'urf'
    source TEXT,     -- 'ugg', 'opgg', 'lolalytics'
    patch TEXT,
    runes JSON,
    items JSON,
    timestamp INTEGER,
    PRIMARY KEY (champion_id, role, game_mode, source, patch)
);
```

**Performance:**
```
Cache Hit (95% of cases):
‚îú‚îÄ Cache lookup:    < 10ms
‚îú‚îÄ Apply runes:     ~50ms
‚îú‚îÄ Write item set:  ~10ms
‚îî‚îÄ TOTAL:           ~70ms ‚úì INSTANT

Cache Miss (5% of cases):
‚îú‚îÄ API fetch:       ~300ms
‚îú‚îÄ Apply runes:     ~50ms
‚îú‚îÄ Write items:     ~10ms
‚îî‚îÄ TOTAL:           ~360ms ‚úì ACCEPTABLE
```

---

## CACHING STRATEGY

### Phase 1: Startup (0 seconds)
- App starts immediately
- Cache empty, ready to go

### Phase 2: Background Pre-fetch (30 seconds)
- Fetch top 50 popular champions √ó 5 roles √ó 3 sources
- 750 entries = 90% of all picks
- Users can start playing immediately

### Phase 3: Complete Cache (10 minutes)
- Fetch remaining champions in background
- Total: 3,784 entries (ALL champs, ALL modes)
- User never notices

### Storage Requirements:

**Complete Cache:**
```
172 champions total (Jan 2026)

Summoner's Rift:  172 √ó 5 roles √ó 3 sources = 2,580 entries
ARAM:             172 √ó 1 build √ó 3 sources = 516 entries
URF/Arena:        172 √ó 2 builds √ó 2 sources = 688 entries
TOTAL:            3,784 entries

Size:
- Uncompressed:   ~3.5 MB
- Compressed:     ~1.5 MB
- With 3 patches: ~3.6 MB

RECOMMENDATION: Cache everything! 3.5 MB is nothing.
```

---

## DATA SOURCES

### Best Sources to Support:

1. **U.GG** (Primary)
   - URL structure: `https://stats2.u.gg/lol/1.5/overview/{patch}/ranked_solo_5x5/{champion}/...`
   - Format: JSON-like (easy to parse)
   - Algorithmic recommendations (highest frequency + above baseline winrate)

2. **OP.GG** (Secondary)
   - URL: `https://na.op.gg/champion/{name}/statistics/{role}`
   - Format: HTML (scraping required)
   - Allows scraping per TOS (cite source)

3. **Lolalytics** (Tertiary)
   - Detailed statistics
   - Good for advanced users

### Scraping vs API:

**U.GG Approach:**
```python
# U.GG has structured endpoints
url = f"https://stats2.u.gg/lol/1.5/overview/{patch}/ranked_solo_5x5/{champion_id}/{role}/1.5.0.json"
response = requests.get(url).json()
runes = response['runes']
items = response['items']
```

**OP.GG Approach:**
```python
# Scraping HTML
from bs4 import BeautifulSoup

url = f"https://na.op.gg/champion/{champion_name}/statistics/{role}"
html = requests.get(url).text
soup = BeautifulSoup(html, 'html.parser')
runes = soup.find_all('div', class_='perk-page__item--active')
```

---

## IMPLEMENTATION ROADMAP

### Milestone 1: MVP (Core Functionality)
```python
‚úì LCU connector (process detection, auth, WebSocket)
‚úì Champion lock detection
‚úì U.GG rune scraper
‚úì Rune application via LCU API
‚úì Basic system tray UI
```

### Milestone 2: Item Sets
```python
‚úì Item build scraper (U.GG)
‚úì File writer (Config/Champions/.../Recommended/)
‚úì Champion key mapping (Data Dragon)
```

### Milestone 3: Caching
```python
‚úì SQLite database setup
‚úì Background cache warmer
‚úì Cache hit/miss logic
‚úì Auto-refresh on patch change
```

### Milestone 4: Multi-Source
```python
‚úì OP.GG scraper
‚úì Lolalytics scraper
‚úì User preference settings
‚úì Source selection UI
```

### Milestone 5: Polish
```python
‚úì ARAM mode support
‚úì Error handling & fallbacks
‚úì Auto-updater
‚úì Installer/packaging
```

---

## TECH STACK RECOMMENDATION

### Backend (Python)
```python
Core:
- Python 3.10+
- asyncio/aiohttp (async HTTP)
- websockets (LCU WebSocket)
- sqlite3 (caching)

Scraping:
- requests (HTTP)
- beautifulsoup4 (HTML parsing)
- lxml (fast XML/HTML)

LCU:
- psutil (process detection)
- base64 (auth encoding)

Utils:
- json (data parsing)
- zlib (compression)
- pathlib (file handling)
```

### Frontend (Minimal)
```python
Option A: System Tray Only
- pystray (cross-platform tray)
- pillow (tray icons)

Option B: Simple GUI
- PyQt6 (native widgets)
- OR tkinter (built-in)

Option C: Web UI (like Singular Tweaks)
- Flask (lightweight web server)
- HTML/CSS/JS (minimal frontend)
```

---

## FILE STRUCTURE

```
your-app/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ lcu/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ connector.py      # LCU connection, auth
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ websocket.py      # WebSocket event handler
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api.py            # REST API wrapper
‚îÇ   ‚îú‚îÄ‚îÄ providers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py           # Abstract provider
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ugg.py            # U.GG scraper
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ opgg.py           # OP.GG scraper
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ lolalytics.py     # Lolalytics scraper
‚îÇ   ‚îú‚îÄ‚îÄ cache/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.py       # SQLite manager
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ warmer.py         # Background pre-fetch
‚îÇ   ‚îú‚îÄ‚îÄ runes/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ manager.py        # Rune application logic
‚îÇ   ‚îú‚îÄ‚îÄ items/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ writer.py         # Item set file writer
‚îÇ   ‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tray.py           # System tray
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ settings.py       # Settings window
‚îÇ   ‚îî‚îÄ‚îÄ main.py               # Entry point
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ champions.json        # Data Dragon mappings
‚îÇ   ‚îî‚îÄ‚îÄ cache.db              # SQLite cache
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ settings.json         # User preferences
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ README.md
```

---

## KEY ALGORITHMS

### Champion Lock Handler:
```python
@lcu_event('/lol-champ-select/v1/session')
async def on_champion_lock(data):
    champion_id = data['myTeam'][local_player]['championId']
    role = data['myTeam'][local_player]['assignedPosition']
    
    # Check cache first
    cached = cache.get(champion_id, role, user_source, current_patch)
    
    if cached:
        # FAST PATH: ~70ms
        apply_runes(cached['runes'])
        write_item_set(champion_id, cached['items'])
        
        # Async refresh if stale
        if is_stale(cached):
            asyncio.create_task(refresh_cache(champion_id, role))
    else:
        # SLOW PATH: ~360ms
        data = await fetch_builds(champion_id, role, user_source)
        apply_runes(data['runes'])
        write_item_set(champion_id, data['items'])
        cache.set(champion_id, role, user_source, current_patch, data)
```

### Cache Warmer:
```python
async def warm_cache():
    patch = get_current_patch()
    popular = get_popular_champions(50)
    
    for champ in popular:
        for role in ['top', 'jungle', 'mid', 'adc', 'support']:
            for source in ['ugg', 'opgg', 'lolalytics']:
                try:
                    data = await fetch_builds(champ, role, source)
                    cache.set(champ, role, source, patch, data)
                    await asyncio.sleep(0.2)  # Rate limiting
                except Exception as e:
                    logger.error(f"Cache warm failed: {champ} {role} {source}")
```

---

## COMPETITIVE ADVANTAGES

### Why Your App Will Win:

1. **Lightweight**
   - 50-80 MB RAM vs 400-600 MB (Mobalytics)
   - 65 MB install vs 250 MB
   - No Overwolf/Chromium bloat

2. **Faster**
   - 70ms average vs 500ms+ (cached)
   - Smart pre-fetching
   - Instant for popular picks

3. **No Ads**
   - Zero telemetry
   - No paywalls
   - Privacy-focused

4. **Multi-Source**
   - User chooses preferred source
   - Fallback if one fails
   - All cached simultaneously

5. **Comprehensive**
   - ALL 172 champions
   - ALL game modes (Rift, ARAM, URF)
   - 3.5 MB cache = everything

---

## EDGE CASES TO HANDLE

### 1. Patch Updates
```python
def on_new_patch(new_patch):
    # Invalidate old patch data
    cache.delete_where(patch != new_patch)
    # Restart cache warming
    asyncio.create_task(warm_cache())
```

### 2. Network Failures
```python
async def fetch_with_fallback(champ, role):
    sources = ['ugg', 'opgg', 'lolalytics']
    for source in sources:
        try:
            return await fetch_from(source, champ, role)
        except:
            continue
    # All failed - use default
    return get_default_runes(champ, role)
```

### 3. Off-Meta Picks
```python
# Yuumi jungle not in cache
# Fetch now (360ms), cache for next time
# User expects slower response for off-meta
```

### 4. LCU Connection Lost
```python
async def reconnect_lcu():
    while True:
        try:
            await lcu.connect()
            break
        except:
            await asyncio.sleep(5)  # Retry every 5s
```

---

## INSTALLATION & DISTRIBUTION

### Development:
```bash
git clone your-repo
cd your-app
pip install -r requirements.txt
python src/main.py
```

### Production:
```bash
# PyInstaller for single executable
pyinstaller --onefile --windowed --icon=app.ico src/main.py

# Or use auto-py-to-exe for GUI packaging
# Or Nuitka for better performance
```

### Auto-Update:
```python
# Check GitHub releases
latest = requests.get('https://api.github.com/repos/you/app/releases/latest').json()
if latest['tag_name'] > current_version:
    notify_user_update_available()
```

---

## ESTIMATED EFFORT

### Time Investment:
```
Milestone 1 (MVP):           20-30 hours
Milestone 2 (Items):         10-15 hours
Milestone 3 (Caching):       15-20 hours
Milestone 4 (Multi-source):  10-15 hours
Milestone 5 (Polish):        15-20 hours
TOTAL:                       70-100 hours
```

### Complexity Rating:
```
LCU Integration:     Medium (well-documented)
Web Scraping:        Easy-Medium (many examples)
Caching:             Easy (SQLite is simple)
UI:                  Easy (system tray is minimal)
Performance Tuning:  Medium (async can be tricky)
```

---

## LEGAL & SAFETY

### Riot's Stance:
- ‚úÖ LCU API usage is allowed
- ‚úÖ Item sets are allowed (Riot's old docs)
- ‚úÖ Rune automation is allowed
- ‚ùå Don't bypass rate limits
- ‚ùå Don't cheat/automate gameplay
- ‚ùå Don't modify game files

### Best Practices:
- Register app on Riot Developer Portal
- Rate limit API calls (be nice)
- Cite sources (U.GG, OP.GG credit)
- No telemetry/tracking
- Open source (transparency)

---

## NEXT STEPS

1. **Research Phase** ‚úì COMPLETE
2. **Prototype LCU Connector**
3. **Build U.GG Scraper**
4. **Test Rune Application**
5. **Add Item Sets**
6. **Implement Caching**
7. **Polish UI**
8. **Package & Release**

---

## FINAL SUMMARY

**What You're Building:**
A lightweight, fast, ad-free League of Legends companion that auto-imports runes and items using aggressive caching for instant performance.

**Why It's Better:**
- 6-12x lighter than Mobalytics
- Faster (70ms vs 500ms+)
- No ads, no bloat
- Comprehensive (ALL champs, ALL modes)
- Privacy-focused

**Technical Specs:**
- Platform: Python standalone
- RAM: 50-80 MB
- Cache: 3.5 MB (ALL data)
- Performance: 95%+ cache hit, <70ms response
- Install: 65 MB total

**Storage:**
Cache everything! 3.5 MB for 172 champions √ó all roles √ó all modes is trivial.

**You've got this!** üöÄ
